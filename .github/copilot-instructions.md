# HA WashData – AI Working Notes
- Purpose: Home Assistant custom integration that watches a smart plug’s power to detect washer cycles, store traces, and expose HA entities. Current implementation has detection/storage/labeling; time estimates/program matching are stubbed (`WashDataManager._update_estimates`).
- Scope/guardrails: Work only inside `custom_components/ha_washdata`. Avoid new heavy deps (only `numpy` in manifest). No external/cloud calls; keep storage backward compatible.
- Key modules: `cycle_detector.py` (state machine), `manager.py` (HA wiring, events, notifications, persistence), `profile_store.py` (storage/compression/matching), `sensor.py` & `binary_sensor.py` (entities), `config_flow.py` (config/options menus), `diagnostics.py` (state dump), `tests/test_cycle_detector.py` (unit test). Defaults/constants in `const.py`.
- Cycle detection: moving-average of last 5 power readings; OFF→RUNNING when smoothed power >= `min_power`; remains RUNNING while active; finishes after smoothed power below threshold for `off_delay` seconds. Manager throttles readings to ≥2s spacing. Defaults: `min_power` 5W, `off_delay` 120s (2 minutes, proven reliable). Real devices can be coarse (e.g., 60s poll); still rely on smoothed thresholding.
- Cycle end logic: After smoothed power stays below threshold for `off_delay` seconds, requires stable low power (80% of last 5min readings < 10W raw) to prevent premature cycle end during brief dips. Auto-merge runs after every cycle end (last 3 hours, 30min gap threshold) to fix fragmentation.
- Persistence: `ProfileStore` uses HA `Store` key `ha_washdata.<entry_id>` storing `profiles`, `past_cycles`, optional `active_cycle`. Active cycle snapshot saved ~60s while running and restored on startup. Completed cycles compressed to `[offset_seconds, power]`, hashed `id` (12 chars); retains last 50 cycles.
- Profile management: Options menu "Manage profiles" picks a recent cycle and names it; `create_profile` ties profile name to sample cycle id and stores avg duration. Service `ha_washdata.label_cycle` labels a cycle via `device_id`, `cycle_id`, `profile_name`. Matching exists via `ProfileStore.match_profile` (NumPy similarity) but `_update_estimates` is TODO.
- Noise/auto-tune: Cycles shorter than 120s count as noise; if ≥3 in 24h, manager raises `min_power` (cap 50W) via entry options and notifies (configured notify service or persistent notification).
- Entities: `binary_sensor.running` reflects `STATE_RUNNING`; sensors: `washer_state`, `washer_program` ("detecting..."/"off"), `time_remaining` (minutes or `off`), `cycle_progress` (float placeholder), `current_power`. Entities subscribe to dispatcher `ha_washdata_update_{entry_id}`.
- Events/notifications: Emits HA events `ha_washdata_cycle_started` and `ha_washdata_cycle_ended` (includes `cycle_data`). Optional notifications controlled by options `notify_events` (`cycle_start`, `cycle_finish`) and `notify_service` (e.g., `notify.mobile_app_xyz`); persistent notification fallback when enabled but no service.
- Config/Options flow: Config asks for name, power sensor entity, `min_power`. Options: `min_power`, `off_delay`, notify service, notify events; menu also exposes profile labeling and post-process merge.
- Post-processing: Options menu "post_process" runs `ProfileStore.merge_cycles(hours, gap_threshold=1800)` to merge fragmented cycles in recent window and updates profile sample ids.
- Diagnostics: `diagnostics.py` dumps config entry, manager state, and raw store data (including power traces).
- Testing/workflows: Run `pytest tests/test_cycle_detector.py` (or `python -m pytest tests/test_cycle_detector.py`) for detector logic. No other automation defined.
- Dev tooling: `devtools/mqtt_mock_socket.py` spins up a MQTT autodiscovery mock power sensor + switch to simulate cycles in seconds (uses `paho-mqtt`). Supports `LONG` (~2:39 like provided trace), `MEDIUM` (~1:30), `SHORT` (~0:45) via command payload; `--default` picks the one used when sending `ON`. Speedup compresses time (e.g., 720 => 2h in ~10s), sampling defaults 60s virtual. Toggle the switch entity or publish to command topic. Topics under `homeassistant/`.
- Implementation gaps to prioritize: Fill `WashDataManager._update_estimates` to call `ProfileStore.match_profile`, set `current_program`, `time_remaining`, `cycle_progress`, and `_notify_update()`. Ensure any new writes keep compressed `power_data` format and remain HA-async-friendly.
- Estimation implementation: `_update_estimates` runs every 5 minutes while RUNNING; calls `match_profile` (NumPy similarity on power arrays), logs match result, sets `current_program`/`time_remaining`/`cycle_progress`. Handles both compressed `[offset, power]` and old `[iso_timestamp, power]` formats. Skip when OFF.
- Estimation intent: Periodically (e.g., every 5–10 minutes while RUNNING) compare live trace to stored profiles to guess program, map heating spikes/plateaus to phases, and compute ETA. When power is 0/low and detector is OFF, skip matching/ETA work.
